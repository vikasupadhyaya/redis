name: Deploy Redis Cluster to EKS

on:
  push:
    branches:
      - main
    paths:
      - 'helm/redis/**'
  workflow_dispatch:

env:
  AWS_REGION: 'us-east-1'
  AWS_ACCOUNT_ID: '634250761496'
  AWS_EKS_DEPLOYER_ROLE_NAME: 'github-actions-eks-deployer'
  EKS_CLUSTER_NAME: 'eks-cluster'
  REDIS_HELM_CHART_PATH: './helm/redis' 
  REDIS_VALUES_FILE: 'values.yaml'
  REDIS_NAMESPACE: 'redis'
  REDIS_RELEASE_NAME: 'redis-cluster'

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    
    steps: 
    - name: Checkout repository
      uses: actions/checkout@v4

    # STEP 1: Configure AWS Credentials (OIDC and Output)
    - name: Configure AWS Credentials (OIDC and Output)
      id: aws-creds
      # IMPORTANT: Must use v4 for credential output.
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/${{ env.AWS_EKS_DEPLOYER_ROLE_NAME }}
        aws-region: ${{ env.AWS_REGION }}
        # This tells the action to output the temporary credentials
        role-session-name: GitHubActionsSession 
        output-credentials: true # Crucial addition to expose credentials

    # STEP 2: Set up kubectl and EKS context (Final Fix)
    # We now explicitly export the environment variables in the shell.
    - name: Set up kubectl and EKS context (Using Explicit Credential Export)
      run: |
        echo "Updating Kubeconfig using session credentials..."
        
        # Export the credentials to the shell environment to prevent the recursive assume-role call
        echo "AWS_ACCESS_KEY_ID=${{ steps.aws-creds.outputs.aws-access-key-id }}" >> $GITHUB_ENV
        echo "AWS_SECRET_ACCESS_KEY=${{ steps.aws-creds.outputs.aws-secret-access-key }}" >> $GITHUB_ENV
        echo "AWS_SESSION_TOKEN=${{ steps.aws-creds.outputs.aws-session-token }}" >> $GITHUB_ENV
        
        # Now run update-kubeconfig. It will use the exported environment variables.
        aws eks update-kubeconfig \
          --name ${{ env.EKS_CLUSTER_NAME }} \
          --region ${{ env.AWS_REGION }}
        
        # Verify connectivity
        kubectl cluster-info

    - name: Setup Helm
      uses: azure/setup-helm@v4
      with:
        version: 'v3.12.0'
        
    - name: Add and Update Helm Repository
      run: |
        helm repo add bitnami https://charts.bitnami.com/bitnami
        helm repo update

    - name: Create Kubernetes Namespace if it doesn't exist
      run: kubectl create namespace ${{ env.REDIS_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy Redis Cluster with Helm Upgrade (Atomic)
      id: deploy-redis
      run: |
        echo "Deploying Redis Cluster using Helm chart: bitnami/redis"
        helm upgrade \
          ${{ env.REDIS_RELEASE_NAME }} \
          bitnami/redis --version 23.2.2 \
          --namespace ${{ env.REDIS_NAMESPACE }} \
          --values ${{ env.REDIS_HELM_CHART_PATH }}/${{ env.REDIS_VALUES_FILE }} \
          --install \
          --atomic \
          --wait \
          --timeout 15m

    - name: Verify Redis Cluster Deployment Status
      run: |
        echo "Verifying Redis Cluster StatefulSet status..."
        kubectl rollout status statefulset/${{ env.REDIS_RELEASE_NAME }}-primary -n ${{ env.REDIS_NAMESPACE }} --timeout=300s
        
        REDIS_PASSWORD=$(kubectl get secret -n ${{ env.REDIS_NAMESPACE }} ${{ env.REDIS_RELEASE_NAME }} -o jsonpath='{.data.redis-password}' | base64 --decode)
        REDIS_POD=$(kubectl get pod -n ${{ env.REDIS_NAMESPACE }} -l app.kubernetes.io/instance=${{ env.REDIS_RELEASE_NAME }},app.kubernetes.io/component=primary -o jsonpath='{.items[0].metadata.name}')
        
        echo "All Redis Cluster nodes are reported ready via K8s StatefulSet."
        kubectl get pods -n ${{ env.REDIS_NAMESPACE }} -l app.kubernetes.io/instance=${{ env.REDIS_RELEASE_NAME }}

        echo "Running cluster check via pod: $REDIS_POD"
        kubectl exec -n ${{ env.REDIS_NAMESPACE }} $REDIS_POD -- redis-cli -a "$REDIS_PASSWORD" cluster info | grep "cluster_state:ok"
        
        if [ $? -ne 0 ]; then
          echo "ERROR: Redis Cluster state is NOT OK. Check logs for detail."
          exit 1
        else
          echo "SUCCESS: Redis Cluster state is OK. ðŸŽ‰"
        fi