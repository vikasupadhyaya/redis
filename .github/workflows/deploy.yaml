name: Deploy Redis Cluster to EKS

on:
  push:
    branches:
      - main
    paths:
      - 'helm/redis/**'
  workflow_dispatch:

env:
  AWS_REGION: 'us-east-1'
  EKS_CLUSTER_NAME: 'eks-cluster'
  REDIS_HELM_CHART_PATH: './helm/redis' 
  REDIS_VALUES_FILE: 'values.yaml'
  REDIS_NAMESPACE: 'redis'
  REDIS_RELEASE_NAME: 'redis-cluster'

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure AWS Credentials (OIDC)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::634250761496:role/github-actions-eks-deployer
        aws-region: ${{ env.AWS_REGION }}  

    - name: Set up kubectl and EKS context (Using Assumed Role)
      run: |
        # This command ensures the kubeconfig context uses the currently assumed 
        # role's credentials (set in the previous step) without attempting 
        # a failing recursive AssumeRole.
        aws eks update-kubeconfig \
          --name ${{ env.EKS_CLUSTER_NAME }} \
          --region ${{ env.AWS_REGION }} \
          --role-arn arn:aws:iam::634250761496:role/github-actions-eks-deployer \
          --alias eks-cluster

    - name: Setup Helm
      uses: azure/setup-helm@v4
      with:
        version: 'v3.12.0'
        
    # --- Helm Repo Setup ---
    - name: Add and Update Helm Repository
      run: |
        helm repo add bitnami https://charts.bitnami.com/bitnami
        helm repo update
    # --------------------------------------

    - name: Create Kubernetes Namespace if it doesn't exist
      run: kubectl create namespace ${{ env.REDIS_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy Redis Cluster with Helm Upgrade (Atomic)
      id: deploy-redis
      run: |
        echo "Deploying Redis Cluster using Helm chart: bitnami/redis-cluster"
        helm upgrade \
          ${{ env.REDIS_RELEASE_NAME }} \
          bitnami/redis --version 23.2.2 \
          --namespace ${{ env.REDIS_NAMESPACE }} \
          --values ${{ env.REDIS_HELM_CHART_PATH }}/${{ env.REDIS_VALUES_FILE }} \
          --install \
          --atomic \
          --wait \
          --timeout 15m

    - name: Verify Redis Cluster Deployment Status
      run: |
        echo "Verifying Redis Cluster StatefulSet status..."
        # Wait for Kubernetes resources to be ready
        kubectl rollout status statefulset/${{ env.REDIS_RELEASE_NAME }}-primary -n ${{ env.REDIS_NAMESPACE }} --timeout=300s
        
        # --- IMPROVED SECRET HANDLING ---
        # 1. Retrieve and decode the Redis password secret
        REDIS_PASSWORD=$(kubectl get secret -n ${{ env.REDIS_NAMESPACE }} ${{ env.REDIS_RELEASE_NAME }} -o jsonpath='{.data.redis-password}' | base64 --decode)
        # 2. Retrieve the primary pod name
        REDIS_POD=$(kubectl get pod -n ${{ env.REDIS_NAMESPACE }} -l app.kubernetes.io/instance=${{ env.REDIS_RELEASE_NAME }},app.kubernetes.io/component=primary -o jsonpath='{.items[0].metadata.name}')
        
        echo "All Redis Cluster nodes are reported ready via K8s StatefulSet."
        kubectl get pods -n ${{ env.REDIS_NAMESPACE }} -l app.kubernetes.io/instance=${{ env.REDIS_RELEASE_NAME }}

        # 3. Functional Verification: Check cluster health
        echo "Running cluster check via pod: $REDIS_POD"
        # Use the securely retrieved variable for the password
        kubectl exec -n ${{ env.REDIS_NAMESPACE }} $REDIS_POD -- redis-cli -a "$REDIS_PASSWORD" cluster info | grep "cluster_state:ok"
        
        if [ $? -ne 0 ]; then
          echo "ERROR: Redis Cluster state is NOT OK. Check logs for detail."
          exit 1
        else
          echo "SUCCESS: Redis Cluster state is OK. ðŸŽ‰"
        fi