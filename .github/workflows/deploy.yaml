name: Deploy Redis Cluster to EKS

on:
  push:
    branches:
      - main
    paths:
      - 'helm/redis/**'
  workflow_dispatch:

env:
  AWS_REGION: 'us-east-1'
  # --- MANDATORY: Set your actual Account ID and Role Name here ---
  AWS_ACCOUNT_ID: '634250761496'
  AWS_EKS_DEPLOYER_ROLE_NAME: 'github-actions-eks-deployer'
  # -----------------------------------------------------------------
  EKS_CLUSTER_NAME: 'eks-cluster'
  REDIS_HELM_CHART_PATH: './helm/redis' 
  REDIS_VALUES_FILE: 'values.yaml'
  REDIS_NAMESPACE: 'redis'
  REDIS_RELEASE_NAME: 'redis-cluster'

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    
    # Correct YAML formatting: steps are indented 2 spaces under jobs.deploy
    steps: 
    - name: Checkout repository
      uses: actions/checkout@v4

    # STEP 1: Configure AWS Credentials (OIDC)
    - name: Configure AWS Credentials (OIDC and Output)
      id: aws-creds
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/${{ env.AWS_EKS_DEPLOYER_ROLE_NAME }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActionsSession

    # STEP 2: Set up kubectl and EKS context (CRITICAL FIX)
    # This relies on the environment variables set by the previous step 
    # and avoids the recursive AssumeRole call.
    - name: Set up kubectl and EKS context (Using OIDC Env Credentials)
      run: |
        echo "Updating Kubeconfig using session credentials..."
        aws eks update-kubeconfig \
          --name ${{ env.EKS_CLUSTER_NAME }} \
          --region ${{ env.AWS_REGION }}
        
        kubectl cluster-info

    - name: Setup Helm
      uses: azure/setup-helm@v4
      with:
        version: 'v3.12.0'
        
    - name: Add and Update Helm Repository
      run: |
        helm repo add bitnami https://charts.bitnami.com/bitnami
        helm repo update

    - name: Create Kubernetes Namespace if it doesn't exist
      # This command now uses valid credentials from the updated kubeconfig
      run: kubectl create namespace ${{ env.REDIS_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy Redis Cluster with Helm Upgrade (Atomic)
      id: deploy-redis
      run: |
        echo "Deploying Redis Cluster using Helm chart: bitnami/redis"
        helm upgrade \
          ${{ env.REDIS_RELEASE_NAME }} \
          bitnami/redis --version 23.2.2 \
          --namespace ${{ env.REDIS_NAMESPACE }} \
          --values ${{ env.REDIS_HELM_CHART_PATH }}/${{ env.REDIS_VALUES_FILE }} \
          --install \
          --atomic \
          --wait \
          --timeout 15m

    - name: Verify Redis Cluster Deployment Status
      run: |
        echo "Verifying Redis Cluster StatefulSet status..."
        kubectl rollout status statefulset/${{ env.REDIS_RELEASE_NAME }}-primary -n ${{ env.REDIS_NAMESPACE }} --timeout=300s
        
        REDIS_PASSWORD=$(kubectl get secret -n ${{ env.REDIS_NAMESPACE }} ${{ env.REDIS_RELEASE_NAME }} -o jsonpath='{.data.redis-password}' | base64 --decode)
        REDIS_POD=$(kubectl get pod -n ${{ env.REDIS_NAMESPACE }} -l app.kubernetes.io/instance=${{ env.REDIS_RELEASE_NAME }},app.kubernetes.io/component=primary -o jsonpath='{.items[0].metadata.name}')
        
        echo "All Redis Cluster nodes are reported ready via K8s StatefulSet."
        kubectl get pods -n ${{ env.REDIS_NAMESPACE }} -l app.kubernetes.io/instance=${{ env.REDIS_RELEASE_NAME }}

        echo "Running cluster check via pod: $REDIS_POD"
        kubectl exec -n ${{ env.REDIS_NAMESPACE }} $REDIS_POD -- redis-cli -a "$REDIS_PASSWORD" cluster info | grep "cluster_state:ok"
        
        if [ $? -ne 0 ]; then
          echo "ERROR: Redis Cluster state is NOT OK. Check logs for detail."
          exit 1
        else
          echo "SUCCESS: Redis Cluster state is OK. ðŸŽ‰"
        fi